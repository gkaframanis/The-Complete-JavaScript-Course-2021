/////////////////////////////////////////////////////////////////////////////////////////////////////////
// SELECTING, CREATING AND DELETING ELEMENTS
////////////////////////////////////////////////////////////////////////////////////////////////////////

// To access the whole page we need the documentElement, it's the entire html
console.log(document.documentElement);
// To get the <head></head>
console.log(document.head);
// To get the <body></body>
console.log(document.body);

const header = document.querySelector(".header");
// Returns a NodeList.
const allSections = document.querySelectorAll(".section");
console.log(allSections);

// We don't the selector here.
document.getElementById("section--1");
// It returns an HTMLCollection (it updates automatically when we have additions or removals)
const allButtons = document.getElementsByTagName("button");
console.log(allButtons);
// It also return an HTMLCollection
console.log(document.getElementsByClassName("btn"));

// Creating and inserting element (.insertAdjacentHTML)
// This returns a DOM element
const message = document.createElement("div");
message.classList.add("cookie-message");
message.textContent = "We use cookies for improved functionality and analytics.";
message.innerHTML =
  "We use cookies for improved functionality and analytics. <button class='btn btn--close-cookie'>Got it!</button>";

// The element can't be in two places at once.
// We can use these to move elements also.
// header.prepend(message);
header.append(message);
// header.append(message.cloneNode(true));

// Now they are siblings
// header.before(message);
// header.after(message);

// Delete elements
document.querySelector(".btn--close-cookie").addEventListener("click", function () {
  message.remove();
});


///////////////////////////////////////////////////////////////////////////////////////////////////////////
// STYLE, ATTRIBUTES AND CLASSES
///////////////////////////////////////////////////////////////////////////////////////////////////////////

// Styles (camelCase at the property) - They are set as inline styles
message.style.backgroundColor = "#37383d";
message.style.width = "120%";

// console.log(message.style.height);  // This doesn't return anything 
console.log(message.style.backgroundColor); // It works only for inline styles!!!

// To get styles
console.log(getComputedStyle(message));  // Contains all of the properties and all the values
// for a specific style | The result is string
console.log(getComputedStyle(message).height);

// Number.parseFloat to just take the number without the px.
message.style.height = Number.parseFloat(getComputedStyle(message).height, 10) + 40 + "px";

// Custom properties: css variables defined in the :root (documentElement for JS)
// We need to use setProperty for custom properties
// document.documentElement.style.setProperty("--color-primary", "orangered");

// Attributes
const logo = document.querySelector(".nav__logo");
// Works only for standard properties
console.log(logo.alt);
console.log(logo.className);  // for historical reasons is not class

// To change the value of an attribute
logo.alt = "Beautiful minimalist logo";

// To read a non-standard property we can use the getAttribute()
console.log(logo.getAttribute("designer"));
// The opposite of getAttribute() is the setAttribute()
logo.setAttribute("company", "Bankist");

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// The same applies for the href
console.log(logo.src);  // The absolute version
console.log(logo.getAttribute("src"));  // The relative one

const link = document.querySelector(".nav__link--btn");
console.log(link.href);  // The absolute
console.log(link.getAttribute("href"));  // The relative

// Data attributes (it has to start with data-) [We need to transform the version-number to camelCase.]
// They can be found in the dataset.
console.log(logo.dataset.versionNumber);

// Classes
// logo.classList.add();  // We can add multiple classes separating with commas
// logo.classList.remove();
// logo.classList.toggle();
// logo.classList.contains();


///////////////////////////////////////////////////////////////////////////////////////////////////////
// TYPE OF EVENTS AND EVENT HANDLERS
//////////////////////////////////////////////////////////////////////////////////////////////////////

// An event is a signal that is being generated by a certain DOM node.
// It doesn't matter if we' re listening for the event or not, the event always happens.

const h1 = document.querySelector("h1");

// mouseenter is like the hover in css.
// Using addEventListener()
// h1.addEventListener("mouseenter", (e) => {
//   alert("addEventListener: Great! You are reading the heading ðŸ˜ƒ");
// });

// Event Reference (MDN)
// Another way to attach an eventListener using PROPERTIES.
// It's a bit of OLD SCHOOL!!!!!!!!!!!! Better to use addEventListener(), we add more than one eventHandlers and to remove it.
// h1.onmouseenter = (e) => alert("addEventListener: Great! You are reading the heading ðŸ˜ƒ");

// To remove we need to have the event handling function separately.
// To listen an event just once, but we can put the removeEventListener anywhere we want.
const alertH1 = () => {
  alert("addEventListener: Great! You are reading the heading ðŸ˜ƒ");

  // h1.removeEventListener("mouseenter", alertH1);
}

h1.addEventListener("mouseenter", alertH1);
setTimeout(() => h1.removeEventListener("mouseenter", alertH1), 5000);

// 3rd way to handle events which SHOULD NOT be used with html attributes.
// We define it directly to the html <h1 onclick="alert('HTML alert')">...</h1>

//////////////////////////////////////////////////////////////////////////////////////////////////
// BUBBLING AND CAPTURING
//////////////////////////////////////////////////////////////////////////////////////////////////

// random color (rgb(255, 255, 255))
const randomInt = (min, max) => Math.floor(Math.random() * (max-min + 1) + min);
const randomColor = () =>`rgb(${randomInt(0, 255)}, ${randomInt(0, 255)}, ${randomInt(0, 255)})`;

// Event handlers to the Features links and to the parent elements (nav__link -> nav__item -> nav__links -> nav)
document.querySelector(".nav__link").addEventListener("click", function(e) {
  // this refers to the element at which the event handler is attached. If we use arrow function it refers to the window!!!!!!!!!!
  console.log(this);
  this.style.backgroundColor = randomColor();
  // Where the event happened. LINK, LINK, LINK - LINK, CONTAINER, NAV (The element is first happened.)
  // e.currentTarget === this
  console.log("LINK", e.target, e.currentTarget);

  // To stop the propagation | The parent elements do not change their color.
  // e.stopPropagation();  // In general is not good idea to stop the event propagation.
});

document.querySelector(".nav__links").addEventListener("click", function(e) {
  // The container also got its own random color because of bubbling up.
  // If we click on this the nav__link color stays unchanged
  this.style.backgroundColor = randomColor();
  // Where the event happened. CONTAINER, CONTAINER - CONTAINER, NAV(The element where the event first happened.)
  // e.currentTarget === this
  console.log("CONTAINER", e.target, e.currentTarget);
});

document.querySelector(".nav").addEventListener("click", function(e) {
   // The container also got its own random color because of bubbling up.
   // If we click on this the nav__link  and nav__links color stays unchanged
   this.style.backgroundColor = randomColor();
   // Where the event happened. NAV - NAV (The element where the event first happened.)
   // e.currentTarget === this
   console.log("NAV", e.target, e.currentTarget);
   // If we want to listen to capturing events instead of the bubbling ones, we add a third parameter as true.
   // Now the order is opposite when we click to the link. (NAV -> CONTAINER -> LINK)
}, false);  // To get rid of it we put the default value false.

// The bubbling is pretty important for the event delegation.


/////////////////////////////////////////////////////////////////////////////////////////////////////////
// DOM TRAVERSING (TO SELECT AN ELEMENT BASED ON ANOTHER ELEMENT)
/////////////////////////////////////////////////////////////////////////////////////////////////////////

// From the h1 element we will go upwards, downwards and sideways.

// GOING DOWNWARDS (selecting child elements) | it would go as deep as necessary to the DOM tree, not just for direct children.
// querySelector, querySelectorAll on the element.
console.log(h1.querySelectorAll(".highlight"));
// It's not that used
console.log(h1.childNodes); // This gives every single node for every type it exists
// To get an HTMLCollection of all the children elements inside the h1.
// This works ONLY for direct children.
console.log(h1.children);
// first and last element child
h1.firstElementChild.style.color = "white";
h1.lastElementChild.style.color = "orangered";


// GOING UPWARDS (selecting parents)
// For direct parents
console.log(h1.parentNode);
console.log(h1.parentElement); 

// Not a direct parent SOS SOS SOS
// Set it to a custom CSS variable
h1.closest(".header").style.background = "var(--gradient-secondary)";
h1.closest("h1").style.background = "var(--gradient-primary)";  // It returns the element itself!

// SIDEWAYS (selecting siblings)
// We can always access direct siblings (previous or the next one)
console.log(h1.previousElementSibling);
console.log(h1.nextElementSibling);

// // For nodes, not used 
// console.log(h1.previousSibling);
// console.log(h1.nextSibling);

// The trick to get all the siblings. We move up to the parent and get the parent's children
console.log(h1.parentElement.children);
[...h1.parentElement.children].forEach(function(elem) {
  if(elem != h1) elem.style.transform = "scale(0.5)";
});


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// STICKY NAVIGATION THE SCROLL EVENT
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// 1. We need to create a new IntersectionObserver
const obsCallback = function(entries, observer) {  // entries can be an array of thresholds
  // It will be called each time the observed element is intersecting with the root element at the threshold we defined. (section1 intersecting the viewport at 10%)
  entries.forEach(entry => console.log(entry));  // We get an entry when the target element appears. isIntersecting: false for < threshold.

};

const obsOptions = {
  // The element we want the target element to intersect
  root: null, // the entire viewport using the value null
  // Percentage we want to have visible at the viewport.
  // the percentage of intersection at which the observer callback will be called (10%: 0.1)
  // threshold: 0.1,  

  // 0 means the callback function will be triggered each time the target element moves completely out of the view and also as soon as it enters the view.
  threshold: [0, 0.2], 
};

const observer = new IntersectionObserver(obsCallback, obsOptions);
// 2. We use the observer to observe a certain target
observer.observe(section1);

////////////////////////////////////////////////////////////////////////////////////////////////////////
// LIFECYCLE DOM EVENTS (Right from the moment it first accessed)
////////////////////////////////////////////////////////////////////////////////////////////////////////

// DOMContentLoaded: it's fired as soon as the html is completely parsed (downloaded and converted to the DOM tree)
// All scripts must be downloaded and executed before the DOMContentLoaded event can happen.
// This event doesn't wait for images and other external resources to load, just the html and js.
// We want all our code to be executed only after the DOM is ready. That's why we have the <script> tag at the end of the html
// and we don't need to listen for this event. 

document.addEventListener("DOMContentLoaded", function(e) {
  console.log("HTML parsed and DOM tree built!");
});

// The load event is fired by the window as soon as not only the html is parsed but also all the images and extenal files are loaded like css.
window.addEventListener("load", function(e) {
  console.log("Page fully loaded", e);
}); 

// immediately before a user is about to leave a page | only when it's necessary and data could be lost by accident.
// window.addEventListener("beforeunload", function(e) {
//   e.preventDefault();
//   console.log(e);
//   e.returnValue = ""; // To get asked if we want to leave the page.
// });

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// EFFICIENT SCRIPT LOADING: DEFER AND ASYNC
/////////////////////////////////////////////////////////////////////////////////////////////////////////

